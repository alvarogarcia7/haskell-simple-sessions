zipWith (\x y -> if x `elem` y then y else x:y) [1,2,3] [[1],[2],[3]]
zipWith (\x y -> if x `elem` y then y else x:y) [1,2,3] [[1],[2],[3]]
zipWith (\x y -> if x `elem` y then x:y else y) [1,2,3] [[1],[2],[3]]
zipWith (\x y -> x:y) [1,2,3] [[1],[2],[3]]
zipWith (\x y -> x:y) [1,2,3] [1,2,3]
zipWith (\x y -> [x, y]) [1,2,3] [1,2,3]
zipWith (\x y -> (x, y)) [1,2,3] [1,2,3]
zipWith mkTuple [1,2,3] [1,2,3]
zipWith mkTuple [[1],[2],[3]] [1,2,3]
zipWith mkTuple (map head' [1,2,3]) [1,2,3]
let mkTuple x y = (\x y -> (x, y))
mkTuple x y = (\x y -> (x, y))
zipWith (\x y -> (x, y)) [1,2,3] ["a","b","c"]
zipWith (\x y -> (x, y))[1,2,3] ["a","b","c"]
:t zipWith
merge [1,2,3] ["a","b","c"]
zipWith [1,2,3] ["a","b","c"]
zipWith [1,2,3] ['a,b,c]
zipWith [1,2,3] [a,b,c]
map head' $ map head' [1,2,3]
map head' [1,2,3]
let head' x = [x] 
map (\x->[x]) [1,2,3]
map [x] [1,2,3]
map head [1,2,3]
le
:l Permutations.hs 
:l Permutations.hs 
:l Permutations.hs 
:l Permutations.hs 
merg st1 st2 == ste
merg st1 st2
:l SortedStack.hs 
:l SortedStack.hs 
:l SortedStack.hs 
:l SortedStack.hs 
(==) 1 2 
1 +2 
(+) 1 2
+ 1 2
mod 4 3
4 `mod` 3
4 `mod` 1
4 `compare` 1
compare 4 1
(1:[2,3])
tail [1,2,3]
head [1,2,3]
merg [1,3,3] [2,3,4]
merg st2 st1 == ste
merg st1 st2 == ste
merg st1 st2
:l SortedStack.hs 
:l SortedStack.hs 
:l SortedStack.hs 
:l SortedStack.hs 
2 `compare`  3
2 `compare`  2
2 compare  2
2 < 2
2 eq 2
1 : [1]
push 1 [1]
:l SortedStack.hs 
:l SortedStack.hs 

